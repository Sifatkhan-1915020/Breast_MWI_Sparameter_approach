import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
from scipy.interpolate import interp1d
from scipy.signal import hilbert
import cv2

class BreastPhantomImaging:
    def __init__(self, phantom_radius=0.05):  # 50mm radius
        self.phantom_radius = phantom_radius
        self.frequency_range = np.linspace(17e9, 20e9, 1001)  # 17-20 GHz, 1001 points
        self.c = 3e8  # Speed of light in m/s
        
        # Antenna positions (9 antennas total)
        self.antenna_positions = self._setup_antenna_positions()
        
        # Tissue properties (simplified)
        self.tissue_properties = {
            'skin': {'epsilon_r': 36.4, 'sigma': 2.34},
            'fat': {'epsilon_r': 4.84, 'sigma': 0.262},
            'adipose': {'epsilon_r': 50, 'sigma': 3.46},
            'tumor': {'epsilon_r': 70, 'sigma': 4.0}
        }
    
    def _setup_antenna_positions(self):
        """Setup antenna positions based on the configuration"""
        positions = []
        
        # Antennas 1-7: 30 degree spacing on equator (semicircle)
        for i in range(7):
            angle = i * 30 * np.pi / 180  # Convert to radians
            x = self.phantom_radius * np.cos(angle)
            y = self.phantom_radius * np.sin(angle)
            z = 0  # Equator level
            positions.append([x, y, z])
        
        # Antenna 8: Top pole
        positions.append([0, 0, self.phantom_radius])
        
        # Antenna 9: Bottom pole  
        positions.append([0, 0, -self.phantom_radius])
        
        return np.array(positions)
    
    def load_s_parameters(self, csv_file_path):
        """Load S-parameter data from CSV file"""
        try:
            # Read the CSV file
            df = pd.read_csv(csv_file_path)
            
            # Extract frequency and S-parameters
            frequency = df['Freqnecy'].values * 1e9  # Convert GHz to Hz
            s_params = df.iloc[:, 1:].values  # All antenna S-parameters
            
            return frequency, s_params
        except Exception as e:
            print(f"Error loading S-parameters: {e}")
            return None, None
    
    def preprocess_signals(self, frequency, s_params):
        """Preprocess S-parameter signals"""
        # Convert S-parameters from dB to linear scale
        s_linear = 10**(s_params / 20)
        
        # Apply time-domain conversion using inverse FFT
        time_signals = []
        
        for i in range(s_linear.shape[1]):
            # Get frequency domain signal
            freq_signal = s_linear[:, i]
            
            # Apply Hilbert transform to get analytic signal
            analytic_signal = hilbert(freq_signal)
            
            # Convert to time domain
            time_signal = np.fft.ifft(analytic_signal)
            time_signals.append(time_signal)
        
        return np.array(time_signals)
    
    def calculate_propagation_delay(self, antenna_idx, pixel_position):
        """Calculate propagation delay from antenna to pixel and back"""
        antenna_pos = self.antenna_positions[antenna_idx]
        
        # Distance from antenna to pixel
        distance = np.linalg.norm(pixel_position - antenna_pos)
        
        # Assume average dielectric properties for delay calculation
        avg_epsilon_r = 20  # Average of tissue properties
        avg_velocity = self.c / np.sqrt(avg_epsilon_r)
        
        # Round trip delay
        delay = 2 * distance / avg_velocity
        
        return delay
    
    def delay_and_sum_beamforming(self, time_signals, image_size=(100, 100, 50)):
        """Implement delay-and-sum beamforming algorithm"""
        x_size, y_size, z_size = image_size
        
        # Create imaging grid
        x_range = np.linspace(-self.phantom_radius, self.phantom_radius, x_size)
        y_range = np.linspace(-self.phantom_radius, self.phantom_radius, y_size)
        z_range = np.linspace(-self.phantom_radius, self.phantom_radius, z_size)
        
        # Initialize reconstructed image
        reconstructed_image = np.zeros((x_size, y_size, z_size))
        
        # Time axis for signals
        dt = 1 / (2 * np.max(self.frequency_range))
        time_axis = np.arange(len(time_signals[0])) * dt
        
        print("Starting image reconstruction...")
        
        for i, x in enumerate(x_range):
            if i % 10 == 0:
                print(f"Processing slice {i}/{x_size}")
                
            for j, y in enumerate(y_range):
                for k, z in enumerate(z_range):
                    pixel_pos = np.array([x, y, z])
                    
                    # Check if pixel is inside phantom
                    if np.linalg.norm(pixel_pos) > self.phantom_radius:
                        continue
                    
                    # Sum delayed signals from all antennas
                    pixel_intensity = 0
                    
                    for ant_idx in range(len(self.antenna_positions)):
                        # Calculate delay for this antenna-pixel pair
                        delay = self.calculate_propagation_delay(ant_idx, pixel_pos)
                        
                        # Find corresponding time index
                        time_idx = int(delay / dt)
                        
                        if 0 <= time_idx < len(time_signals[ant_idx]):
                            # Add delayed signal contribution
                            signal_value = np.abs(time_signals[ant_idx][time_idx])
                            pixel_intensity += signal_value
                    
                    reconstructed_image[i, j, k] = pixel_intensity
        
        return reconstructed_image, (x_range, y_range, z_range)
    
    def enhance_tumor_visualization(self, image):
        """Apply image enhancement techniques for better tumor visualization"""
        # Normalize image
        image_norm = (image - np.min(image)) / (np.max(image) - np.min(image))
        
        # Apply dynamic range compression
        image_enhanced = np.power(image_norm, 0.5)
        
        # Apply median filtering to reduce noise
        for z in range(image_enhanced.shape[2]):
            image_enhanced[:, :, z] = cv2.medianBlur(
                (image_enhanced[:, :, z] * 255).astype(np.uint8), 3
            ) / 255.0
        
        return image_enhanced
    
    def visualize_results(self, image, grid_ranges, save_path=None):
        """Visualize reconstruction results"""
        x_range, y_range, z_range = grid_ranges
        
        # Create figure with multiple subplots
        fig, axes = plt.subplots(2, 3, figsize=(15, 10))
        
        # XY plane (axial slices)
        z_center = len(z_range) // 2
        im1 = axes[0, 0].imshow(image[:, :, z_center].T, 
                               extent=[x_range[0]*1000, x_range[-1]*1000, 
                                      y_range[0]*1000, y_range[-1]*1000],
                               aspect='equal', cmap='Blues', origin='lower')
        axes[0, 0].set_title('XY Plane (Axial)')
        axes[0, 0].set_xlabel('X (mm)')
        axes[0, 0].set_ylabel('Y (mm)')
        plt.colorbar(im1, ax=axes[0, 0])
        
        # XZ plane (coronal slices)
        y_center = len(y_range) // 2
        im2 = axes[0, 1].imshow(image[:, y_center, :].T,
                               extent=[x_range[0]*1000, x_range[-1]*1000,
                                      z_range[0]*1000, z_range[-1]*1000],
                               aspect='equal', cmap='Blues', origin='lower')
        axes[0, 1].set_title('XZ Plane (Coronal)')
        axes[0, 1].set_xlabel('X (mm)')
        axes[0, 1].set_ylabel('Z (mm)')
        plt.colorbar(im2, ax=axes[0, 1])
        
        # YZ plane (sagittal slices)
        x_center = len(x_range) // 2
        im3 = axes[0, 2].imshow(image[x_center, :, :].T,
                               extent=[y_range[0]*1000, y_range[-1]*1000,
                                      z_range[0]*1000, z_range[-1]*1000],
                               aspect='equal', cmap='Blues', origin='lower')
        axes[0, 2].set_title('YZ Plane (Sagittal)')
        axes[0, 2].set_xlabel('Y (mm)')
        axes[0, 2].set_ylabel('Z (mm)')
        plt.colorbar(im3, ax=axes[0, 2])
        
        # 3D visualization (maximum intensity projection)
        max_proj_xy = np.max(image, axis=2)
        max_proj_xz = np.max(image, axis=1)
        max_proj_yz = np.max(image, axis=0)
        
        im4 = axes[1, 0].imshow(max_proj_xy.T,
                               extent=[x_range[0]*1000, x_range[-1]*1000,
                                      y_range[0]*1000, y_range[-1]*1000],
                               aspect='equal', cmap='Blues', origin='lower')
        axes[1, 0].set_title('Maximum Intensity Projection (XY)')
        axes[1, 0].set_xlabel('X (mm)')
        axes[1, 0].set_ylabel('Y (mm)')
        plt.colorbar(im4, ax=axes[1, 0])
        
        im5 = axes[1, 1].imshow(max_proj_xz.T,
                               extent=[x_range[0]*1000, x_range[-1]*1000,
                                      z_range[0]*1000, z_range[-1]*1000],
                               aspect='equal', cmap='Blues', origin='lower')
        axes[1, 1].set_title('Maximum Intensity Projection (XZ)')
        axes[1, 1].set_xlabel('X (mm)')
        axes[1, 1].set_ylabel('Z (mm)')
        plt.colorbar(im5, ax=axes[1, 1])
        
        im6 = axes[1, 2].imshow(max_proj_yz.T,
                               extent=[y_range[0]*1000, y_range[-1]*1000,
                                      z_range[0]*1000, z_range[-1]*1000],
                               aspect='equal', cmap='Blues', origin='lower')
        axes[1, 2].set_title('Maximum Intensity Projection (YZ)')
        axes[1, 2].set_xlabel('Y (mm)')
        axes[1, 2].set_ylabel('Z (mm)')
        plt.colorbar(im6, ax=axes[1, 2])
        
        plt.tight_layout()
        
        if save_path:
            plt.savefig(save_path, dpi=300, bbox_inches='tight')
        
        plt.show()

def main():
    """Main reconstruction pipeline"""
    # Initialize imaging system
    imaging_system = BreastPhantomImaging(phantom_radius=0.05)
    
    # Load S-parameter data (replace with your CSV file path)
    csv_file_path = "tumor_rad_5.csv"  # Update this path
    frequency, s_params = imaging_system.load_s_parameters(csv_file_path)
    
    if frequency is None:
        print("Failed to load S-parameter data. Creating synthetic data for demonstration.")
        # Create synthetic data for demonstration
        frequency = np.linspace(17e9, 20e9, 1001)
        s_params = np.random.randn(1001, 9) * 5 - 50  # Random S-parameters in dB
    
    print(f"Loaded S-parameter data: {s_params.shape}")
    print(f"Frequency range: {frequency[0]/1e9:.2f} - {frequency[-1]/1e9:.2f} GHz")
    
    # Preprocess signals
    print("Preprocessing signals...")
    time_signals = imaging_system.preprocess_signals(frequency, s_params)
    
    # Perform image reconstruction
    print("Starting image reconstruction (this may take several minutes)...")
    reconstructed_image, grid_ranges = imaging_system.delay_and_sum_beamforming(
        time_signals, image_size=(60, 60, 30)  # Reduced size for faster computation
    )
    
    # Enhance tumor visualization
    print("Enhancing image for tumor visualization...")
    enhanced_image = imaging_system.enhance_tumor_visualization(reconstructed_image)
    
    # Visualize results
    print("Visualizing results...")
    imaging_system.visualize_results(enhanced_image, grid_ranges, 
                                   save_path="breast_reconstruction_results.png")
    
    print("Reconstruction complete!")
    
    return enhanced_image, grid_ranges

if __name__ == "__main__":
    # Run the main reconstruction pipeline
    result_image, grid_ranges = main()
